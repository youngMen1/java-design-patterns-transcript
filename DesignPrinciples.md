# 涉及的相关的设计原则

## 单一职责原则
定义:
**应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change）**

单一职责原则为我们提供了一个编写程序的准则，要求我们在编写类，抽象类，接口时，要使其功能职责单一纯碎，
将导致其变更的因素缩减到最少。
**如果一个类承担的职责过多，就等于把这些职责耦合在一起。一个职责的变化可能会影响或损坏其他职责的功能。
而且职责越多，这个类变化的几率就会越大，类的稳定性就会越低。**
在软件开发中，经常会遇到一个功能类T负责两个不同的职责：职责P1，职责P2。
现因需求变更需要更改职责P1来满足新的业务需求，当我们实现完成后，
发现因更改职责P1竟导致原本能够正常运行的职责P2发生故障。而修复职责P2又不得不更改职责P1的逻辑，
这便是因为功能类T的职责不够单一，职责P1与职责P2耦合在一起导致的。


## 里氏替换原则(LSP)
定义:
如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序p的行为没有发生变化，那么类型T2是类型T1的子类型。

问题由来
有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。

解决方案
当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
### 里氏替换原则包含了四层含义:
1.子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
2.子类中可以增加自己特性
3.类的方法重载父类的方法时，方法的前置条件(形参)要比父类方法的输入参数更宽松
4 覆写或者实现父类的方法时输出结果(返回值)可以被缩小
父类的一个方法的返回值是一个类型T，子类的相同方法（重载或者重写）的返回值为S，那么里氏替换原则就要求S必须小于等于T。

总结
有子类出现的地方父类未必就可以出现
父类出现的地方子类就可以出现


## 依赖倒置原则(DIP)
定义:
* 高层模块不应该依赖低层模块，两者都应该依赖抽象
* 抽象不应该依赖细节
* 细节应该依赖抽象

依赖倒置原则在java语言中，表现是:
* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
* 接口或抽象类不依赖实现类
* 实现类依赖接口或抽象类

依赖倒置原则的经验
依赖倒置原则的本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。我们在项目中使用这个原则要遵循下面的规则：

每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备
变量的表面类型尽量是接口或者抽象类
任何类都不应该从具体类派生
尽量不要覆写基类的方法
如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。
结合里氏替换原则使用
大家只要记住是”面向接口编程”就基本上是抓住了依赖倒置原则的核心了


## 接口隔离原则(Interface Segregation Principle, ISP)
定义:
* Clients should not be forced to depend upon interfaces that they don’t use. 
（客户端不应该依赖它不需要的接口。）
* The dependency of one class to another one should depend on the smallest possible interface. 
（类间的依赖关系应该建立在最小的接口上。）

接口隔离原则是对接口的使用进行约束规范的一个原则，它告诉我们要想把接口用好，
关键在于隔离。隔离，指断绝接触、断绝往来。那么我们使用接口时，
要隔离什么东西呢？对于上述定义的第1点，“客户端不应该依赖它不需要的接口”，
这里的隔离是指客户端和它不需要的接口隔离，也就是客户端不要使用它不需要的接口，
这个很容易理解，在实践中也很容易实现。我们着重看一下第2点，“类间的依赖关系应该建立在最小的接口上”，
它要求“最小的接口”，也就是该接口中没有多余的方法，所以这里的隔离是指和多余的方法隔离。

好处:
1.避免接口污染
2.提高灵活性
3.提供定制服务
4.实现高内聚


## 迪米特法则(Least Knowledge Principle, LKP)
定义:
迪米特法则(Law of Demeter, LoD)是1987年秋天由lan holland在美国东北大学一个叫做迪米特的项目设计提出的，
它要求一个对象应该对其他对象有最少的了解，所以迪米特法则又叫做最少知识原则（Least Knowledge Principle, LKP）。

意义:
迪米特法则的意义在于降低类之间的耦合。由于每个对象尽量减少对其他对象的了解，
因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。
值得一提的是，这一法则却不仅仅局限于计算机领域，在其他领域也同样适用。
比如，美国人就在航天系统的设计中采用这一法则。

实践
那么在实践中如何做到一个对象应该对其他对象有最少的了解呢？如果我们把一个对象看作是一个人，
那么要实现“一个人应该对其他人有最少的了解”，
做到两点就足够了：1.只和直接的朋友交流；2.减少对朋友的了解。下面就详细说说如何做到这两点。

注意：
只出现在方法体内部的类就不是直接的朋友，如果一个类和不是直接的朋友进行交流，就属于违反迪米特法则。

总结
迪米特法则的核心观念就是类间解耦，弱耦合。只有弱耦合了之后，类的复用才可以提高，类变更的风险才可以减低。
但解耦是有限度的，除非是计算机的最小单元--二进制的0和1，否则都是存在耦合的。所以在实际项目中，
需要适度地参考这个原则，避免过犹不及。

## 开闭原则(OCP)
定义:一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。

介绍:
开闭原则明确的告诉我们：软件实现应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，
而不是通过修改已有的代码来实现变化的。那什么是软件实体呢？软件实体包括以下几个部分：
* 项目或软件产品中按照一定的逻辑规则划分的模块
* 抽象和类
* 方法
一个软件产品只要在生命周期内，都会发生变化，即然变化是一个事实，
我们就应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性，真正实现“拥抱变化”。
开闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改现有代码来完成变化，
它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。

为什么使用开闭原则:
1.开闭原则非常有名，只要是面向对象编程，在开发时都会强调开闭原则
2.开闭原则是最基础的设计原则，其它的五个设计原则都是开闭原则的具体形态，也就是说其它的五个设计原则是指导设计的工具和方法，
而开闭原则才是其精神领袖。依照java语言的称谓，开闭原则是抽象类，而其它的五个原则是具体的实现类。
3.开闭原则可以提高复用性,在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来，
不是在一个类中独立实现一个业务逻辑。只有这样的代码才可以复用，粒度越小，被复用的可能性越大。
那为什么要复用呢？减少代码的重复，避免相同的逻辑分散在多个角落，减少维护人员的工作量。
那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可以分为止。
4.开闭原则可以提高维护性,一款软件量产后，维护人员的工作不仅仅对数据进行维护，还可能要对程序进行扩展，
维护人员最乐意的事是扩展一个类，而不是修改一个类。让维护人员读懂原有代码，再进行修改，
是一件非常痛苦的事情，不要让他在原有的代码海洋中游荡后再修改，那是对维护人员的折磨和摧残。
5.面向对象开发的要求,万物皆对象，我们要把所有的事物抽象成对象，然后针对对象进行操作，
但是万物皆发展变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，
然后留下接口，等待“可能”转变为“现实”。

如何使用开闭原则
一、抽象约束
抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。
因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，
其包含三层含义：
通过接口或抽象类约束扩散，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法。
参数类型，引用对象尽量使用接口或抽象类，而不是实现类，这主要是实现里氏替换原则的一个要求
抽象层尽量保持稳定，一旦确定就不要修改

二、元数据(metadata)控件模块行为
编程是一个很苦很累的活，那怎么才能减轻压力呢？答案是尽量使用元数据来控制程序的行为，减少重复开发。
什么是元数据？用来描述环境和数据的数据，通俗的说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。

三、制定项目章程
在一个团队中，建立项目章程是非常重要的，因为章程是所有人员都必须遵守的约定，对项目来说，约定优于配置。
这比通过接口或抽象类进行约束效率更高，而扩展性一点也没有减少。

四、封装变化
对变化封装包含两层含义：
(1) 将相同的变化封装到一个接口或抽象类中
(2) 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。
封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口。
